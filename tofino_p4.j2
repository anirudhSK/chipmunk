#include <tofino/intrinsic_metadata.p4>
#include "tofino/stateful_alu_blackbox.p4"

/* Declare Header */
header_type ethernet_t {
    fields {
        dstAddr : 48;
        srcAddr : 48;
        etherType : 16;
    }
}

header ethernet_t ethernet;

header_type ipv4_t {
    fields { // Variable: can use these fields for output from packet processing program.
             // Note: this is just for ease of prototyping. In practice, we would use a separate header for this.
        field1 : 32;
        field2 : 32;
        field3 : 32; 
        field4 : 32;
        field5 : 32;
    }
}

header ipv4_t ipv4;

/* Declare Parser */
parser start {
	return select(current(96,16)){
		0x0800: parse_ethernet;
	}
}

parser parse_ethernet {
    extract(ethernet);
    return select(latest.etherType) {
        /** Fill Whatever ***/
        0x0800     : parse_ipv4;
        default: ingress;
    }
}
parser parse_ipv4 {
    extract(ipv4);
    return ingress;
}

// TODO: Derive MAX_SIZE from Domino program.
#define MAX_SIZE 10
register {{reg_name}} {
    width : 64;
    instance_count : MAX_SIZE;
}

blackbox stateful_alu {{salu_name}} {
    reg : {{reg_name}};
    condition_lo : {{ condition_lo_expr }};
    condition_hi : {{ condition_hi_expr }};
    update_lo_1_predicate : {{ update_lo_1_predicate_expr }};
    update_lo_1_value : {{ update_lo_1_value_expr }};
    update_lo_2_predicate : {{ update_lo_2_predicate_expr }};
    update_lo_2_value : {{update_lo_2_value_expr}};
    update_hi_1_predicate : {{update_hi_1_predicate_expr}};
    update_hi_1_value : {{update_hi_1_value_expr}};
    update_hi_2_predicate : {{update_hi_2_predicate_expr}};
    update_hi_2_value : {{update_hi_2_value_expr}};
    output_predicate : {{output_predicate_expr}};
    output_value : {{ output_value_expr }};
    output_dst : {{ output_dst_expr }};
    initial_register_lo_value : {{initial_register_lo_value_expr}};
    initial_register_hi_value : {{initial_register_hi_value_expr}};
}

// Stateful ALU Action
action {{salu_action_name}} () {
    {{salu_name}}.execute_stateful_alu(0);
    // TODO: Replace 0 with appropriate value for array-based registers.
}

// Stateful ALU table
// (use pragmas to enforce table placement in certain stages)
@pragma stage {{stage_number}}
table {{salu_table_name}} {
    actions {
        {{salu_action_name}}; // action1 for SALU
    }
    default_action: {{salu_action_name}};
}

// Stateless ALU action
action {{stateless_alu_action_name}} () {
   {{stateless_alu_expr}};
}

// Stateless ALU table
@pragma stage {{stage_number}}
table {{stateless_alu_table_name}} {
    actions {
        {{stateless_alu_action_name}};
    }
    default_action: {{stateless_alu_action_name}};
}

// Variable: Create as many stateful and stateless tables as required depending on the grid size.

// Required: mac_forward table for forwarding to switch CPU.
action set_egr(egress_spec) {
    modify_field(ig_intr_md_for_tm.ucast_egress_port, egress_spec);
}
table mac_forward {
    reads {
        ethernet.dstAddr : exact;
    }
    actions {
        set_egr;
    }
    size:1;
}

control ingress {
    // Call all the required ALUs.
    {{alu_apply_statements}}
    // MAC Forwarding by default
    apply(mac_forward);
}

control egress {

}
