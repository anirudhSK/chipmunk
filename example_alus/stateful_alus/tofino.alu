type : stateful
state variables : {state_0, state_1} // register_lo, register_hi
hole variables : {}
packet fields : {pkt_0, pkt_1} // metadata_lo, metadata_hi

// compute_alu(A, B), where A can be metadata or constant
// where B can be register or constant

// NOTE: rel_op doesn't support >-, <= but it should be enough because
// bitwise_op has support for ~.

if ((bitwise_op(rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                           arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                       0),
                rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                           arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                       0))) &
    (bitwise_op(rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                           arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                       0),
                rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                           arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                       0)))) {
  state_1 =
      (compute_alu(Mux3(pkt_0, pkt_1, C()), Mux3(state_0, state_1, C()))) |
      (compute_alu(Mux3(pkt_0, pkt_1, C()), Mux3(state_0, state_1, C())));
} else if ((bitwise_op(rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                                  arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                              0),
                       rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                                  arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                              0))) &
           (~(bitwise_op(
               rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                          arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                      0),
               rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                          arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                      0))))) {
  state_1 = (compute_alu(Mux3(pkt_0, pkt_1, C()), Mux3(state_0, state_1, C())));
} else if ((~(bitwise_op(
               rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                          arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                      0),
               rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                          arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                      0)))) &
           (bitwise_op(rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                                  arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                              0),
                       rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                                  arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                              0)))) {
  state_1 = (compute_alu(Mux3(pkt_0, pkt_1, C()), Mux3(state_0, state_1, C())));
} else {
  state_1 = state_1;
}

if ((bitwise_op(rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                           arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                       0),
                rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                           arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                       0))) &
    (bitwise_op(rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                           arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                       0),
                rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                           arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                       0)))) {
  state_0 =
      (compute_alu(Mux3(pkt_0, pkt_1, C()), Mux3(state_0, state_1, C()))) |
      (compute_alu(Mux3(pkt_0, pkt_1, C()), Mux3(state_0, state_1, C())));
} else if ((bitwise_op(rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                                  arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                              0),
                       rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                                  arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                              0))) &
           (~(bitwise_op(
               rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                          arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                      0),
               rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                          arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                      0))))) {
  state_0 = (compute_alu(Mux3(pkt_0, pkt_1, C()), Mux3(state_0, state_1, C())));
} else if ((~(bitwise_op(
               rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                          arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                      0),
               rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                          arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                      0)))) &
           (bitwise_op(rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                                  arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                              0),
                       rel_op(arith_op(0, Mux3(pkt_0, pkt_1, 0)) +
                                  arith_op(0, Mux3(state_0, state_1, 0)) + C(),
                              0)))) {
  state_0 = (compute_alu(Mux3(pkt_0, pkt_1, C()), Mux3(state_0, state_1, C())));
} else {
  state_0 = state_0;
}

// TODO: We can only update one metadata field, and we don't know at this point
// which one will get updated. We would return simply one value from here and
// let the output mux choose. To handle this, we would like to change all
// stateful alus to return one single integer value and modify related Python
// sketch generator scripts to accomodate this.
pkt_1 = Mux5(pkt_1, pkt_0, state_0, state_1, 0)
